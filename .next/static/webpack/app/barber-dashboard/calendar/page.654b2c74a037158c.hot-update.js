"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/barber-dashboard/calendar/page",{

/***/ "(app-pages-browser)/./src/lib/booking.ts":
/*!****************************!*\
  !*** ./src/lib/booking.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bookAppointment: function() { return /* binding */ bookAppointment; },\n/* harmony export */   cancelAppointment: function() { return /* binding */ cancelAppointment; },\n/* harmony export */   getAppointmentsByBarber: function() { return /* binding */ getAppointmentsByBarber; },\n/* harmony export */   getAppointmentsByClient: function() { return /* binding */ getAppointmentsByClient; },\n/* harmony export */   subscribeToAppointments: function() { return /* binding */ subscribeToAppointments; }\n/* harmony export */ });\n/* harmony import */ var _supabaseClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabaseClient */ \"(app-pages-browser)/./src/lib/supabaseClient.ts\");\n\nasync function bookAppointment(slot, clientId) {\n    const appointmentDate = new Date(slot.start_time).toISOString().split(\"T\")[0];\n    const appointmentTime = new Date(slot.start_time).toLocaleTimeString(\"en-US\", {\n        hour12: false,\n        hour: \"2-digit\",\n        minute: \"2-digit\"\n    });\n    // Fetch client name and email from users table\n    const { data: user, error: userError } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"name, email\").eq(\"id\", clientId).single();\n    if (userError || !user) {\n        throw new Error(\"Could not fetch client info\");\n    }\n    console.log(\"Booking appointment:\", {\n        date: appointmentDate,\n        time: appointmentTime,\n        barberId: slot.barber_id,\n        clientId: clientId,\n        clientName: user.name,\n        clientEmail: user.email\n    });\n    const { data, error } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"appointments\").insert([\n        {\n            barber_id: slot.barber_id,\n            client_id: clientId,\n            client_name: user.name,\n            client_email: user.email,\n            barbershop_id: slot.barbershop_id,\n            service_id: slot.service_id || null,\n            appointment_date: appointmentDate,\n            appointment_time: appointmentTime,\n            status: \"booked\",\n            notes: slot.notes || null\n        }\n    ]).select(\"\\n            *,\\n            barbers:barber_id (\\n                id,\\n                name,\\n                photo_url\\n            ),\\n            barbershops:barbershop_id (\\n                id,\\n                name,\\n                address\\n            ),\\n            services:service_id (\\n                id,\\n                name,\\n                price\\n            )\\n        \").single();\n    if (error) {\n        console.error(\"Supabase error:\", error);\n        throw error;\n    }\n    return data;\n}\nasync function getAppointmentsByBarber(barberId, date) {\n    console.log(\"Fetching appointments for barber:\", barberId, \"on date:\", date);\n    const { data, error } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"appointments\").select(\"\\n            *,\\n            barbers:barber_id (\\n                id,\\n                name,\\n                photo_url\\n            ),\\n            barbershops:barbershop_id (\\n                id,\\n                name,\\n                address\\n            ),\\n            client:client_id (\\n                id,\\n                name,\\n                phone\\n            )\\n        \").eq(\"barber_id\", barberId).eq(\"appointment_date\", date).order(\"appointment_time\");\n    if (error) {\n        console.error(\"Error fetching appointments:\", error);\n        throw error;\n    }\n    console.log(\"Fetched appointments:\", data);\n    return data || [];\n}\nasync function getAppointmentsByClient(clientId) {\n    const { data, error } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"appointments\").select(\"\\n            *,\\n            services,\\n            barbers:barber_id (\\n                id,\\n                name,\\n                photo_url\\n            ),\\n            barbershops:barbershop_id (\\n                id,\\n                name,\\n                address\\n            )\\n        \").eq(\"client_id\", clientId).order(\"appointment_date\", {\n        ascending: false\n    }).order(\"appointment_time\", {\n        ascending: false\n    });\n    if (error) throw error;\n    return data;\n}\nasync function cancelAppointment(appointmentId) {\n    const { error } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"appointments\").update({\n        status: \"cancelled\"\n    }).eq(\"id\", appointmentId);\n    if (error) throw error;\n}\nfunction subscribeToAppointments(barberId, onAppointmentChange) {\n    const channel = _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.channel(\"appointments\").on(\"postgres_changes\", {\n        event: \"*\",\n        schema: \"public\",\n        table: \"appointments\",\n        filter: \"barber_id=eq.\".concat(barberId)\n    }, (payload)=>{\n        onAppointmentChange(payload.new);\n    }).subscribe();\n    return ()=>{\n        _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.removeChannel(channel);\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYm9va2luZy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNEM7QUE0Q3JDLGVBQWVDLGdCQUFnQkMsSUFBaUIsRUFBRUMsUUFBZ0I7SUFDckUsTUFBTUMsa0JBQWtCLElBQUlDLEtBQUtILEtBQUtJLFVBQVUsRUFBRUMsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDN0UsTUFBTUMsa0JBQWtCLElBQUlKLEtBQUtILEtBQUtJLFVBQVUsRUFBRUksa0JBQWtCLENBQUMsU0FBUztRQUMxRUMsUUFBUTtRQUNSQyxNQUFNO1FBQ05DLFFBQVE7SUFDWjtJQUVBLCtDQUErQztJQUMvQyxNQUFNLEVBQUVDLE1BQU1DLElBQUksRUFBRUMsT0FBT0MsU0FBUyxFQUFFLEdBQUcsTUFBTWpCLHFEQUFRQSxDQUNsRGtCLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsZUFDUEMsRUFBRSxDQUFDLE1BQU1qQixVQUNUa0IsTUFBTTtJQUNYLElBQUlKLGFBQWEsQ0FBQ0YsTUFBTTtRQUNwQixNQUFNLElBQUlPLE1BQU07SUFDcEI7SUFFQUMsUUFBUUMsR0FBRyxDQUFDLHdCQUF3QjtRQUNoQ0MsTUFBTXJCO1FBQ05zQixNQUFNakI7UUFDTmtCLFVBQVV6QixLQUFLMEIsU0FBUztRQUN4QnpCLFVBQVVBO1FBQ1YwQixZQUFZZCxLQUFLZSxJQUFJO1FBQ3JCQyxhQUFhaEIsS0FBS2lCLEtBQUs7SUFDM0I7SUFFQSxNQUFNLEVBQUVsQixJQUFJLEVBQUVFLEtBQUssRUFBRSxHQUFHLE1BQU1oQixxREFBUUEsQ0FDakNrQixJQUFJLENBQUMsZ0JBQ0xlLE1BQU0sQ0FBQztRQUNKO1lBQ0lMLFdBQVcxQixLQUFLMEIsU0FBUztZQUN6Qk0sV0FBVy9CO1lBQ1hnQyxhQUFhcEIsS0FBS2UsSUFBSTtZQUN0Qk0sY0FBY3JCLEtBQUtpQixLQUFLO1lBQ3hCSyxlQUFlbkMsS0FBS21DLGFBQWE7WUFDakNDLFlBQVlwQyxLQUFLb0MsVUFBVSxJQUFJO1lBQy9CQyxrQkFBa0JuQztZQUNsQm9DLGtCQUFrQi9CO1lBQ2xCZ0MsUUFBUTtZQUNSQyxPQUFPeEMsS0FBS3dDLEtBQUssSUFBSTtRQUN6QjtLQUNILEVBQ0F2QixNQUFNLENBQUUseVlBa0JSRSxNQUFNO0lBRVgsSUFBSUwsT0FBTztRQUNQTyxRQUFRUCxLQUFLLENBQUMsbUJBQW1CQTtRQUNqQyxNQUFNQTtJQUNWO0lBQ0EsT0FBT0Y7QUFDWDtBQUVPLGVBQWU2Qix3QkFBd0JoQixRQUFnQixFQUFFRixJQUFZO0lBQ3hFRixRQUFRQyxHQUFHLENBQUMscUNBQXFDRyxVQUFVLFlBQVlGO0lBRXZFLE1BQU0sRUFBRVgsSUFBSSxFQUFFRSxLQUFLLEVBQUUsR0FBRyxNQUFNaEIscURBQVFBLENBQ2pDa0IsSUFBSSxDQUFDLGdCQUNMQyxNQUFNLENBQUUsc1lBa0JSQyxFQUFFLENBQUMsYUFBYU8sVUFDaEJQLEVBQUUsQ0FBQyxvQkFBb0JLLE1BQ3ZCbUIsS0FBSyxDQUFDO0lBRVgsSUFBSTVCLE9BQU87UUFDUE8sUUFBUVAsS0FBSyxDQUFDLGdDQUFnQ0E7UUFDOUMsTUFBTUE7SUFDVjtJQUVBTyxRQUFRQyxHQUFHLENBQUMseUJBQXlCVjtJQUNyQyxPQUFPQSxRQUFRLEVBQUU7QUFDckI7QUFFTyxlQUFlK0Isd0JBQXdCMUMsUUFBZ0I7SUFDMUQsTUFBTSxFQUFFVyxJQUFJLEVBQUVFLEtBQUssRUFBRSxHQUFHLE1BQU1oQixxREFBUUEsQ0FDakNrQixJQUFJLENBQUMsZ0JBQ0xDLE1BQU0sQ0FBRSwwU0FjUkMsRUFBRSxDQUFDLGFBQWFqQixVQUNoQnlDLEtBQUssQ0FBQyxvQkFBb0I7UUFBRUUsV0FBVztJQUFNLEdBQzdDRixLQUFLLENBQUMsb0JBQW9CO1FBQUVFLFdBQVc7SUFBTTtJQUVsRCxJQUFJOUIsT0FBTyxNQUFNQTtJQUNqQixPQUFPRjtBQUNYO0FBRU8sZUFBZWlDLGtCQUFrQkMsYUFBcUI7SUFDekQsTUFBTSxFQUFFaEMsS0FBSyxFQUFFLEdBQUcsTUFBTWhCLHFEQUFRQSxDQUMzQmtCLElBQUksQ0FBQyxnQkFDTCtCLE1BQU0sQ0FBQztRQUFFUixRQUFRO0lBQVksR0FDN0JyQixFQUFFLENBQUMsTUFBTTRCO0lBRWQsSUFBSWhDLE9BQU8sTUFBTUE7QUFDckI7QUFFTyxTQUFTa0Msd0JBQ1p2QixRQUFnQixFQUNoQndCLG1CQUF1RDtJQUV2RCxNQUFNQyxVQUFVcEQscURBQVFBLENBQ25Cb0QsT0FBTyxDQUFDLGdCQUNSQyxFQUFFLENBQ0Msb0JBQ0E7UUFDSUMsT0FBTztRQUNQQyxRQUFRO1FBQ1JDLE9BQU87UUFDUEMsUUFBUSxnQkFBeUIsT0FBVDlCO0lBQzVCLEdBQ0EsQ0FBQytCO1FBQ0dQLG9CQUFvQk8sUUFBUUMsR0FBRztJQUNuQyxHQUVIQyxTQUFTO0lBRWQsT0FBTztRQUNINUQscURBQVFBLENBQUM2RCxhQUFhLENBQUNUO0lBQzNCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9ib29raW5nLnRzP2FkYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICcuL3N1cGFiYXNlQ2xpZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBCb29raW5nU2xvdCB7XG4gICAgc3RhcnRfdGltZTogc3RyaW5nO1xuICAgIGVuZF90aW1lOiBzdHJpbmc7XG4gICAgYmFyYmVyX2lkOiBzdHJpbmc7XG4gICAgYmFyYmVyc2hvcF9pZDogc3RyaW5nO1xuICAgIHNlcnZpY2VfaWQ/OiBzdHJpbmcgfCBudWxsO1xuICAgIG5vdGVzPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcHBvaW50bWVudCB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBiYXJiZXJfaWQ6IHN0cmluZztcbiAgICBjbGllbnRfaWQ6IHN0cmluZztcbiAgICBiYXJiZXJzaG9wX2lkOiBzdHJpbmc7XG4gICAgc2VydmljZV9pZD86IHN0cmluZyB8IG51bGw7XG4gICAgYXBwb2ludG1lbnRfZGF0ZTogc3RyaW5nO1xuICAgIGFwcG9pbnRtZW50X3RpbWU6IHN0cmluZztcbiAgICBzdGF0dXM6ICdib29rZWQnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJztcbiAgICBub3Rlcz86IHN0cmluZyB8IG51bGw7XG4gICAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAgIGJhcmJlcnM/OiB7XG4gICAgICAgIGlkOiBzdHJpbmc7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgcGhvdG9fdXJsOiBzdHJpbmc7XG4gICAgfTtcbiAgICBiYXJiZXJzaG9wcz86IHtcbiAgICAgICAgaWQ6IHN0cmluZztcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICBhZGRyZXNzOiBzdHJpbmc7XG4gICAgfTtcbiAgICBzZXJ2aWNlcz86IHtcbiAgICAgICAgaWQ6IHN0cmluZztcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICBwcmljZTogbnVtYmVyO1xuICAgIH07XG4gICAgY2xpZW50Pzoge1xuICAgICAgICBpZDogc3RyaW5nO1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIHBob25lOiBzdHJpbmc7XG4gICAgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJvb2tBcHBvaW50bWVudChzbG90OiBCb29raW5nU2xvdCwgY2xpZW50SWQ6IHN0cmluZyk6IFByb21pc2U8QXBwb2ludG1lbnQ+IHtcbiAgICBjb25zdCBhcHBvaW50bWVudERhdGUgPSBuZXcgRGF0ZShzbG90LnN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICBjb25zdCBhcHBvaW50bWVudFRpbWUgPSBuZXcgRGF0ZShzbG90LnN0YXJ0X3RpbWUpLnRvTG9jYWxlVGltZVN0cmluZygnZW4tVVMnLCB7XG4gICAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcbiAgICAgICAgbWludXRlOiAnMi1kaWdpdCdcbiAgICB9KTtcblxuICAgIC8vIEZldGNoIGNsaWVudCBuYW1lIGFuZCBlbWFpbCBmcm9tIHVzZXJzIHRhYmxlXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAuc2VsZWN0KCduYW1lLCBlbWFpbCcpXG4gICAgICAgIC5lcSgnaWQnLCBjbGllbnRJZClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgIGlmICh1c2VyRXJyb3IgfHwgIXVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmV0Y2ggY2xpZW50IGluZm8nKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnQm9va2luZyBhcHBvaW50bWVudDonLCB7XG4gICAgICAgIGRhdGU6IGFwcG9pbnRtZW50RGF0ZSxcbiAgICAgICAgdGltZTogYXBwb2ludG1lbnRUaW1lLFxuICAgICAgICBiYXJiZXJJZDogc2xvdC5iYXJiZXJfaWQsXG4gICAgICAgIGNsaWVudElkOiBjbGllbnRJZCxcbiAgICAgICAgY2xpZW50TmFtZTogdXNlci5uYW1lLFxuICAgICAgICBjbGllbnRFbWFpbDogdXNlci5lbWFpbFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2FwcG9pbnRtZW50cycpXG4gICAgICAgIC5pbnNlcnQoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJhcmJlcl9pZDogc2xvdC5iYXJiZXJfaWQsXG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiBjbGllbnRJZCxcbiAgICAgICAgICAgICAgICBjbGllbnRfbmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgICAgIGNsaWVudF9lbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgICAgICAgICBiYXJiZXJzaG9wX2lkOiBzbG90LmJhcmJlcnNob3BfaWQsXG4gICAgICAgICAgICAgICAgc2VydmljZV9pZDogc2xvdC5zZXJ2aWNlX2lkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgYXBwb2ludG1lbnRfZGF0ZTogYXBwb2ludG1lbnREYXRlLFxuICAgICAgICAgICAgICAgIGFwcG9pbnRtZW50X3RpbWU6IGFwcG9pbnRtZW50VGltZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdib29rZWQnLFxuICAgICAgICAgICAgICAgIG5vdGVzOiBzbG90Lm5vdGVzIHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSlcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgICAqLFxuICAgICAgICAgICAgYmFyYmVyczpiYXJiZXJfaWQgKFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgcGhvdG9fdXJsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYmFyYmVyc2hvcHM6YmFyYmVyc2hvcF9pZCAoXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgc2VydmljZXM6c2VydmljZV9pZCAoXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBwcmljZVxuICAgICAgICAgICAgKVxuICAgICAgICBgKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBcHBvaW50bWVudHNCeUJhcmJlcihiYXJiZXJJZDogc3RyaW5nLCBkYXRlOiBzdHJpbmcpOiBQcm9taXNlPEFwcG9pbnRtZW50W10+IHtcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgYXBwb2ludG1lbnRzIGZvciBiYXJiZXI6JywgYmFyYmVySWQsICdvbiBkYXRlOicsIGRhdGUpO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2FwcG9pbnRtZW50cycpXG4gICAgICAgIC5zZWxlY3QoYFxuICAgICAgICAgICAgKixcbiAgICAgICAgICAgIGJhcmJlcnM6YmFyYmVyX2lkIChcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHBob3RvX3VybFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGJhcmJlcnNob3BzOmJhcmJlcnNob3BfaWQgKFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYWRkcmVzc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNsaWVudDpjbGllbnRfaWQgKFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgcGhvbmVcbiAgICAgICAgICAgIClcbiAgICAgICAgYClcbiAgICAgICAgLmVxKCdiYXJiZXJfaWQnLCBiYXJiZXJJZClcbiAgICAgICAgLmVxKCdhcHBvaW50bWVudF9kYXRlJywgZGF0ZSlcbiAgICAgICAgLm9yZGVyKCdhcHBvaW50bWVudF90aW1lJyk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYXBwb2ludG1lbnRzOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0ZldGNoZWQgYXBwb2ludG1lbnRzOicsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXBwb2ludG1lbnRzQnlDbGllbnQoY2xpZW50SWQ6IHN0cmluZyk6IFByb21pc2U8QXBwb2ludG1lbnRbXT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdhcHBvaW50bWVudHMnKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICAgICosXG4gICAgICAgICAgICBzZXJ2aWNlcyxcbiAgICAgICAgICAgIGJhcmJlcnM6YmFyYmVyX2lkIChcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHBob3RvX3VybFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGJhcmJlcnNob3BzOmJhcmJlcnNob3BfaWQgKFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYWRkcmVzc1xuICAgICAgICAgICAgKVxuICAgICAgICBgKVxuICAgICAgICAuZXEoJ2NsaWVudF9pZCcsIGNsaWVudElkKVxuICAgICAgICAub3JkZXIoJ2FwcG9pbnRtZW50X2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgLm9yZGVyKCdhcHBvaW50bWVudF90aW1lJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbmNlbEFwcG9pbnRtZW50KGFwcG9pbnRtZW50SWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdhcHBvaW50bWVudHMnKVxuICAgICAgICAudXBkYXRlKHsgc3RhdHVzOiAnY2FuY2VsbGVkJyB9KVxuICAgICAgICAuZXEoJ2lkJywgYXBwb2ludG1lbnRJZCk7XG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlVG9BcHBvaW50bWVudHMoXG4gICAgYmFyYmVySWQ6IHN0cmluZyxcbiAgICBvbkFwcG9pbnRtZW50Q2hhbmdlOiAoYXBwb2ludG1lbnQ6IEFwcG9pbnRtZW50KSA9PiB2b2lkXG4pIHtcbiAgICBjb25zdCBjaGFubmVsID0gc3VwYWJhc2VcbiAgICAgICAgLmNoYW5uZWwoJ2FwcG9pbnRtZW50cycpXG4gICAgICAgIC5vbihcbiAgICAgICAgICAgICdwb3N0Z3Jlc19jaGFuZ2VzJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBldmVudDogJyonLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogJ3B1YmxpYycsXG4gICAgICAgICAgICAgICAgdGFibGU6ICdhcHBvaW50bWVudHMnLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogYGJhcmJlcl9pZD1lcS4ke2JhcmJlcklkfWBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQXBwb2ludG1lbnRDaGFuZ2UocGF5bG9hZC5uZXcgYXMgQXBwb2ludG1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgfTtcbn0gIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiYm9va0FwcG9pbnRtZW50Iiwic2xvdCIsImNsaWVudElkIiwiYXBwb2ludG1lbnREYXRlIiwiRGF0ZSIsInN0YXJ0X3RpbWUiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiYXBwb2ludG1lbnRUaW1lIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiaG91cjEyIiwiaG91ciIsIm1pbnV0ZSIsImRhdGEiLCJ1c2VyIiwiZXJyb3IiLCJ1c2VyRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJkYXRlIiwidGltZSIsImJhcmJlcklkIiwiYmFyYmVyX2lkIiwiY2xpZW50TmFtZSIsIm5hbWUiLCJjbGllbnRFbWFpbCIsImVtYWlsIiwiaW5zZXJ0IiwiY2xpZW50X2lkIiwiY2xpZW50X25hbWUiLCJjbGllbnRfZW1haWwiLCJiYXJiZXJzaG9wX2lkIiwic2VydmljZV9pZCIsImFwcG9pbnRtZW50X2RhdGUiLCJhcHBvaW50bWVudF90aW1lIiwic3RhdHVzIiwibm90ZXMiLCJnZXRBcHBvaW50bWVudHNCeUJhcmJlciIsIm9yZGVyIiwiZ2V0QXBwb2ludG1lbnRzQnlDbGllbnQiLCJhc2NlbmRpbmciLCJjYW5jZWxBcHBvaW50bWVudCIsImFwcG9pbnRtZW50SWQiLCJ1cGRhdGUiLCJzdWJzY3JpYmVUb0FwcG9pbnRtZW50cyIsIm9uQXBwb2ludG1lbnRDaGFuZ2UiLCJjaGFubmVsIiwib24iLCJldmVudCIsInNjaGVtYSIsInRhYmxlIiwiZmlsdGVyIiwicGF5bG9hZCIsIm5ldyIsInN1YnNjcmliZSIsInJlbW92ZUNoYW5uZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/booking.ts\n"));

/***/ })

});