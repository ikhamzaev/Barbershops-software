"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/barber-dashboard/calendar/page",{

/***/ "(app-pages-browser)/./src/lib/booking.ts":
/*!****************************!*\
  !*** ./src/lib/booking.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bookAppointment: function() { return /* binding */ bookAppointment; },\n/* harmony export */   cancelAppointment: function() { return /* binding */ cancelAppointment; },\n/* harmony export */   getAppointmentsByBarber: function() { return /* binding */ getAppointmentsByBarber; },\n/* harmony export */   getAppointmentsByClient: function() { return /* binding */ getAppointmentsByClient; },\n/* harmony export */   subscribeToAppointments: function() { return /* binding */ subscribeToAppointments; }\n/* harmony export */ });\n/* harmony import */ var _supabaseClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabaseClient */ \"(app-pages-browser)/./src/lib/supabaseClient.ts\");\n\nasync function bookAppointment(slot, clientId) {\n    const appointmentDate = new Date(slot.start_time).toISOString().split(\"T\")[0];\n    const appointmentTime = new Date(slot.start_time).toLocaleTimeString(\"en-US\", {\n        hour12: false,\n        hour: \"2-digit\",\n        minute: \"2-digit\"\n    });\n    // Fetch client name and email from users table\n    const { data: user, error: userError } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"name, email\").eq(\"id\", clientId).single();\n    if (userError || !user) {\n        throw new Error(\"Could not fetch client info\");\n    }\n    console.log(\"Booking appointment:\", {\n        date: appointmentDate,\n        time: appointmentTime,\n        barberId: slot.barber_id,\n        clientId: clientId,\n        clientName: user.name,\n        clientEmail: user.email\n    });\n    const { data, error } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"appointments\").insert([\n        {\n            barber_id: slot.barber_id,\n            client_id: clientId,\n            client_name: user.name,\n            client_email: user.email,\n            barbershop_id: slot.barbershop_id,\n            service_id: slot.service_id || null,\n            appointment_date: appointmentDate,\n            appointment_time: appointmentTime,\n            status: \"booked\",\n            notes: slot.notes || null\n        }\n    ]).select(\"\\n            *,\\n            barbers:barber_id (\\n                id,\\n                name,\\n                photo_url\\n            ),\\n            barbershops:barbershop_id (\\n                id,\\n                name,\\n                address\\n            ),\\n            services:service_id (\\n                id,\\n                name,\\n                price\\n            )\\n        \").single();\n    if (error) {\n        console.error(\"Supabase error:\", error);\n        throw error;\n    }\n    return data;\n}\nasync function getAppointmentsByBarber(barberId, date) {\n    console.log(\"Fetching appointments for barber:\", barberId, \"on date:\", date);\n    const { data, error } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"appointments\").select(\"\\n            *,\\n            barbers:barber_id (\\n                id,\\n                name,\\n                photo_url\\n            ),\\n            barbershops:barbershop_id (\\n                id,\\n                name,\\n                address\\n            ),\\n            client:client_id (\\n                id,\\n                name,\\n                phone\\n            )\\n        \").eq(\"barber_id\", barberId).eq(\"appointment_date\", date).order(\"appointment_time\");\n    if (error) {\n        console.error(\"Error fetching appointments:\", error);\n        throw error;\n    }\n    console.log(\"Fetched appointments:\", data);\n    return data || [];\n}\nasync function getAppointmentsByClient(clientId) {\n    const { data, error } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"appointments\").select(\"\\n            *,\\n            services,\\n            barbers:barber_id (\\n                id,\\n                name,\\n                photo_url\\n            ),\\n            barbershops:barbershop_id (\\n                id,\\n                name,\\n                address\\n            )\\n        \").eq(\"client_id\", clientId).order(\"appointment_date\", {\n        ascending: false\n    }).order(\"appointment_time\", {\n        ascending: false\n    });\n    if (error) throw error;\n    return data;\n}\nasync function cancelAppointment(appointmentId) {\n    const { error } = await _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"appointments\").update({\n        status: \"cancelled\"\n    }).eq(\"id\", appointmentId);\n    if (error) throw error;\n}\nfunction subscribeToAppointments(barberId, onAppointmentChange) {\n    const channel = _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.channel(\"appointments\").on(\"postgres_changes\", {\n        event: \"*\",\n        schema: \"public\",\n        table: \"appointments\",\n        filter: \"barber_id=eq.\".concat(barberId)\n    }, (payload)=>{\n        onAppointmentChange(payload.new);\n    }).subscribe();\n    return ()=>{\n        _supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.removeChannel(channel);\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYm9va2luZy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNEM7QUE0Q3JDLGVBQWVDLGdCQUFnQkMsSUFBaUIsRUFBRUMsUUFBZ0I7SUFDckUsTUFBTUMsa0JBQWtCLElBQUlDLEtBQUtILEtBQUtJLFVBQVUsRUFBRUMsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDN0UsTUFBTUMsa0JBQWtCLElBQUlKLEtBQUtILEtBQUtJLFVBQVUsRUFBRUksa0JBQWtCLENBQUMsU0FBUztRQUMxRUMsUUFBUTtRQUNSQyxNQUFNO1FBQ05DLFFBQVE7SUFDWjtJQUVBLCtDQUErQztJQUMvQyxNQUFNLEVBQUVDLE1BQU1DLElBQUksRUFBRUMsT0FBT0MsU0FBUyxFQUFFLEdBQUcsTUFBTWpCLHFEQUFRQSxDQUNsRGtCLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsZUFDUEMsRUFBRSxDQUFDLE1BQU1qQixVQUNUa0IsTUFBTTtJQUNYLElBQUlKLGFBQWEsQ0FBQ0YsTUFBTTtRQUNwQixNQUFNLElBQUlPLE1BQU07SUFDcEI7SUFFQUMsUUFBUUMsR0FBRyxDQUFDLHdCQUF3QjtRQUNoQ0MsTUFBTXJCO1FBQ05zQixNQUFNakI7UUFDTmtCLFVBQVV6QixLQUFLMEIsU0FBUztRQUN4QnpCLFVBQVVBO1FBQ1YwQixZQUFZZCxLQUFLZSxJQUFJO1FBQ3JCQyxhQUFhaEIsS0FBS2lCLEtBQUs7SUFDM0I7SUFFQSxNQUFNLEVBQUVsQixJQUFJLEVBQUVFLEtBQUssRUFBRSxHQUFHLE1BQU1oQixxREFBUUEsQ0FDakNrQixJQUFJLENBQUMsZ0JBQ0xlLE1BQU0sQ0FBQztRQUNKO1lBQ0lMLFdBQVcxQixLQUFLMEIsU0FBUztZQUN6Qk0sV0FBVy9CO1lBQ1hnQyxhQUFhcEIsS0FBS2UsSUFBSTtZQUN0Qk0sY0FBY3JCLEtBQUtpQixLQUFLO1lBQ3hCSyxlQUFlbkMsS0FBS21DLGFBQWE7WUFDakNDLFlBQVlwQyxLQUFLb0MsVUFBVSxJQUFJO1lBQy9CQyxrQkFBa0JuQztZQUNsQm9DLGtCQUFrQi9CO1lBQ2xCZ0MsUUFBUTtZQUNSQyxPQUFPeEMsS0FBS3dDLEtBQUssSUFBSTtRQUN6QjtLQUNILEVBQ0F2QixNQUFNLENBQUUseVlBa0JSRSxNQUFNO0lBRVgsSUFBSUwsT0FBTztRQUNQTyxRQUFRUCxLQUFLLENBQUMsbUJBQW1CQTtRQUNqQyxNQUFNQTtJQUNWO0lBQ0EsT0FBT0Y7QUFDWDtBQUVPLGVBQWU2Qix3QkFBd0JoQixRQUFnQixFQUFFRixJQUFZO0lBQ3hFRixRQUFRQyxHQUFHLENBQUMscUNBQXFDRyxVQUFVLFlBQVlGO0lBRXZFLE1BQU0sRUFBRVgsSUFBSSxFQUFFRSxLQUFLLEVBQUUsR0FBRyxNQUFNaEIscURBQVFBLENBQ2pDa0IsSUFBSSxDQUFDLGdCQUNMQyxNQUFNLENBQUUsc1lBa0JSQyxFQUFFLENBQUMsYUFBYU8sVUFDaEJQLEVBQUUsQ0FBQyxvQkFBb0JLLE1BQ3ZCbUIsS0FBSyxDQUFDO0lBRVgsSUFBSTVCLE9BQU87UUFDUE8sUUFBUVAsS0FBSyxDQUFDLGdDQUFnQ0E7UUFDOUMsTUFBTUE7SUFDVjtJQUVBTyxRQUFRQyxHQUFHLENBQUMseUJBQXlCVjtJQUNyQyxPQUFPQSxRQUFRLEVBQUU7QUFDckI7QUFFTyxlQUFlK0Isd0JBQXdCMUMsUUFBZ0I7SUFDMUQsTUFBTSxFQUFFVyxJQUFJLEVBQUVFLEtBQUssRUFBRSxHQUFHLE1BQU1oQixxREFBUUEsQ0FDakNrQixJQUFJLENBQUMsZ0JBQ0xDLE1BQU0sQ0FBRSwwU0FjUkMsRUFBRSxDQUFDLGFBQWFqQixVQUNoQnlDLEtBQUssQ0FBQyxvQkFBb0I7UUFBRUUsV0FBVztJQUFNLEdBQzdDRixLQUFLLENBQUMsb0JBQW9CO1FBQUVFLFdBQVc7SUFBTTtJQUVsRCxJQUFJOUIsT0FBTyxNQUFNQTtJQUNqQixPQUFPRjtBQUNYO0FBRU8sZUFBZWlDLGtCQUFrQkMsYUFBcUI7SUFDekQsTUFBTSxFQUFFaEMsS0FBSyxFQUFFLEdBQUcsTUFBTWhCLHFEQUFRQSxDQUMzQmtCLElBQUksQ0FBQyxnQkFDTCtCLE1BQU0sQ0FBQztRQUFFUixRQUFRO0lBQVksR0FDN0JyQixFQUFFLENBQUMsTUFBTTRCO0lBRWQsSUFBSWhDLE9BQU8sTUFBTUE7QUFDckI7QUFFTyxTQUFTa0Msd0JBQ1p2QixRQUFnQixFQUNoQndCLG1CQUF1RDtJQUV2RCxNQUFNQyxVQUFVcEQscURBQVFBLENBQ25Cb0QsT0FBTyxDQUFDLGdCQUNSQyxFQUFFLENBQ0Msb0JBQ0E7UUFDSUMsT0FBTztRQUNQQyxRQUFRO1FBQ1JDLE9BQU87UUFDUEMsUUFBUSxnQkFBeUIsT0FBVDlCO0lBQzVCLEdBQ0EsQ0FBQytCO1FBQ0dQLG9CQUFvQk8sUUFBUUMsR0FBRztJQUNuQyxHQUVIQyxTQUFTO0lBRWQsT0FBTztRQUNINUQscURBQVFBLENBQUM2RCxhQUFhLENBQUNUO0lBQzNCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9ib29raW5nLnRzP2FkYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICcuL3N1cGFiYXNlQ2xpZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBCb29raW5nU2xvdCB7XG4gICAgc3RhcnRfdGltZTogc3RyaW5nO1xuICAgIGVuZF90aW1lOiBzdHJpbmc7XG4gICAgYmFyYmVyX2lkOiBzdHJpbmc7XG4gICAgYmFyYmVyc2hvcF9pZDogc3RyaW5nO1xuICAgIHNlcnZpY2VfaWQ/OiBzdHJpbmcgfCBudWxsO1xuICAgIG5vdGVzPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcHBvaW50bWVudCB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBiYXJiZXJfaWQ6IHN0cmluZztcbiAgICBjbGllbnRfaWQ6IHN0cmluZztcbiAgICBiYXJiZXJzaG9wX2lkOiBzdHJpbmc7XG4gICAgc2VydmljZV9pZD86IHN0cmluZyB8IG51bGw7XG4gICAgYXBwb2ludG1lbnRfZGF0ZTogc3RyaW5nO1xuICAgIGFwcG9pbnRtZW50X3RpbWU6IHN0cmluZztcbiAgICBzdGF0dXM6ICdib29rZWQnIHwgJ2NvbmZpcm1lZCcgfCAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnO1xuICAgIG5vdGVzPzogc3RyaW5nIHwgbnVsbDtcbiAgICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gICAgYmFyYmVycz86IHtcbiAgICAgICAgaWQ6IHN0cmluZztcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICBwaG90b191cmw6IHN0cmluZztcbiAgICB9O1xuICAgIGJhcmJlcnNob3BzPzoge1xuICAgICAgICBpZDogc3RyaW5nO1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICB9O1xuICAgIHNlcnZpY2VzPzoge1xuICAgICAgICBpZDogc3RyaW5nO1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIHByaWNlOiBudW1iZXI7XG4gICAgfTtcbiAgICBjbGllbnQ/OiB7XG4gICAgICAgIGlkOiBzdHJpbmc7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgcGhvbmU6IHN0cmluZztcbiAgICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYm9va0FwcG9pbnRtZW50KHNsb3Q6IEJvb2tpbmdTbG90LCBjbGllbnRJZDogc3RyaW5nKTogUHJvbWlzZTxBcHBvaW50bWVudD4ge1xuICAgIGNvbnN0IGFwcG9pbnRtZW50RGF0ZSA9IG5ldyBEYXRlKHNsb3Quc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICAgIGNvbnN0IGFwcG9pbnRtZW50VGltZSA9IG5ldyBEYXRlKHNsb3Quc3RhcnRfdGltZSkudG9Mb2NhbGVUaW1lU3RyaW5nKCdlbi1VUycsIHtcbiAgICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgICBtaW51dGU6ICcyLWRpZ2l0J1xuICAgIH0pO1xuXG4gICAgLy8gRmV0Y2ggY2xpZW50IG5hbWUgYW5kIGVtYWlsIGZyb20gdXNlcnMgdGFibGVcbiAgICBjb25zdCB7IGRhdGE6IHVzZXIsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgIC5zZWxlY3QoJ25hbWUsIGVtYWlsJylcbiAgICAgICAgLmVxKCdpZCcsIGNsaWVudElkKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgaWYgKHVzZXJFcnJvciB8fCAhdXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmZXRjaCBjbGllbnQgaW5mbycpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdCb29raW5nIGFwcG9pbnRtZW50OicsIHtcbiAgICAgICAgZGF0ZTogYXBwb2ludG1lbnREYXRlLFxuICAgICAgICB0aW1lOiBhcHBvaW50bWVudFRpbWUsXG4gICAgICAgIGJhcmJlcklkOiBzbG90LmJhcmJlcl9pZCxcbiAgICAgICAgY2xpZW50SWQ6IGNsaWVudElkLFxuICAgICAgICBjbGllbnROYW1lOiB1c2VyLm5hbWUsXG4gICAgICAgIGNsaWVudEVtYWlsOiB1c2VyLmVtYWlsXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnYXBwb2ludG1lbnRzJylcbiAgICAgICAgLmluc2VydChbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmFyYmVyX2lkOiBzbG90LmJhcmJlcl9pZCxcbiAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxuICAgICAgICAgICAgICAgIGNsaWVudF9uYW1lOiB1c2VyLm5hbWUsXG4gICAgICAgICAgICAgICAgY2xpZW50X2VtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgICAgICAgIGJhcmJlcnNob3BfaWQ6IHNsb3QuYmFyYmVyc2hvcF9pZCxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlX2lkOiBzbG90LnNlcnZpY2VfaWQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBhcHBvaW50bWVudF9kYXRlOiBhcHBvaW50bWVudERhdGUsXG4gICAgICAgICAgICAgICAgYXBwb2ludG1lbnRfdGltZTogYXBwb2ludG1lbnRUaW1lLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ2Jvb2tlZCcsXG4gICAgICAgICAgICAgICAgbm90ZXM6IHNsb3Qubm90ZXMgfHwgbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICBdKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICAgICosXG4gICAgICAgICAgICBiYXJiZXJzOmJhcmJlcl9pZCAoXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBwaG90b191cmxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBiYXJiZXJzaG9wczpiYXJiZXJzaG9wX2lkIChcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGFkZHJlc3NcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzZXJ2aWNlczpzZXJ2aWNlX2lkIChcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHByaWNlXG4gICAgICAgICAgICApXG4gICAgICAgIGApXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFwcG9pbnRtZW50c0J5QmFyYmVyKGJhcmJlcklkOiBzdHJpbmcsIGRhdGU6IHN0cmluZyk6IFByb21pc2U8QXBwb2ludG1lbnRbXT4ge1xuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhcHBvaW50bWVudHMgZm9yIGJhcmJlcjonLCBiYXJiZXJJZCwgJ29uIGRhdGU6JywgZGF0ZSk7XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnYXBwb2ludG1lbnRzJylcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgICAqLFxuICAgICAgICAgICAgYmFyYmVyczpiYXJiZXJfaWQgKFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgcGhvdG9fdXJsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYmFyYmVyc2hvcHM6YmFyYmVyc2hvcF9pZCAoXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2xpZW50OmNsaWVudF9pZCAoXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBwaG9uZVxuICAgICAgICAgICAgKVxuICAgICAgICBgKVxuICAgICAgICAuZXEoJ2JhcmJlcl9pZCcsIGJhcmJlcklkKVxuICAgICAgICAuZXEoJ2FwcG9pbnRtZW50X2RhdGUnLCBkYXRlKVxuICAgICAgICAub3JkZXIoJ2FwcG9pbnRtZW50X3RpbWUnKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhcHBvaW50bWVudHM6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnRmV0Y2hlZCBhcHBvaW50bWVudHM6JywgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGEgfHwgW107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBcHBvaW50bWVudHNCeUNsaWVudChjbGllbnRJZDogc3RyaW5nKTogUHJvbWlzZTxBcHBvaW50bWVudFtdPiB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2FwcG9pbnRtZW50cycpXG4gICAgICAgIC5zZWxlY3QoYFxuICAgICAgICAgICAgKixcbiAgICAgICAgICAgIHNlcnZpY2VzLFxuICAgICAgICAgICAgYmFyYmVyczpiYXJiZXJfaWQgKFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgcGhvdG9fdXJsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYmFyYmVyc2hvcHM6YmFyYmVyc2hvcF9pZCAoXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzXG4gICAgICAgICAgICApXG4gICAgICAgIGApXG4gICAgICAgIC5lcSgnY2xpZW50X2lkJywgY2xpZW50SWQpXG4gICAgICAgIC5vcmRlcignYXBwb2ludG1lbnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgICAub3JkZXIoJ2FwcG9pbnRtZW50X3RpbWUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBkYXRhO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FuY2VsQXBwb2ludG1lbnQoYXBwb2ludG1lbnRJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2FwcG9pbnRtZW50cycpXG4gICAgICAgIC51cGRhdGUoeyBzdGF0dXM6ICdjYW5jZWxsZWQnIH0pXG4gICAgICAgIC5lcSgnaWQnLCBhcHBvaW50bWVudElkKTtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmVUb0FwcG9pbnRtZW50cyhcbiAgICBiYXJiZXJJZDogc3RyaW5nLFxuICAgIG9uQXBwb2ludG1lbnRDaGFuZ2U6IChhcHBvaW50bWVudDogQXBwb2ludG1lbnQpID0+IHZvaWRcbikge1xuICAgIGNvbnN0IGNoYW5uZWwgPSBzdXBhYmFzZVxuICAgICAgICAuY2hhbm5lbCgnYXBwb2ludG1lbnRzJylcbiAgICAgICAgLm9uKFxuICAgICAgICAgICAgJ3Bvc3RncmVzX2NoYW5nZXMnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnKicsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiAncHVibGljJyxcbiAgICAgICAgICAgICAgICB0YWJsZTogJ2FwcG9pbnRtZW50cycsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBgYmFyYmVyX2lkPWVxLiR7YmFyYmVySWR9YFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgb25BcHBvaW50bWVudENoYW5nZShwYXlsb2FkLm5ldyBhcyBBcHBvaW50bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgLnN1YnNjcmliZSgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc3VwYWJhc2UucmVtb3ZlQ2hhbm5lbChjaGFubmVsKTtcbiAgICB9O1xufSAiXSwibmFtZXMiOlsic3VwYWJhc2UiLCJib29rQXBwb2ludG1lbnQiLCJzbG90IiwiY2xpZW50SWQiLCJhcHBvaW50bWVudERhdGUiLCJEYXRlIiwic3RhcnRfdGltZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJhcHBvaW50bWVudFRpbWUiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyMTIiLCJob3VyIiwibWludXRlIiwiZGF0YSIsInVzZXIiLCJlcnJvciIsInVzZXJFcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsImRhdGUiLCJ0aW1lIiwiYmFyYmVySWQiLCJiYXJiZXJfaWQiLCJjbGllbnROYW1lIiwibmFtZSIsImNsaWVudEVtYWlsIiwiZW1haWwiLCJpbnNlcnQiLCJjbGllbnRfaWQiLCJjbGllbnRfbmFtZSIsImNsaWVudF9lbWFpbCIsImJhcmJlcnNob3BfaWQiLCJzZXJ2aWNlX2lkIiwiYXBwb2ludG1lbnRfZGF0ZSIsImFwcG9pbnRtZW50X3RpbWUiLCJzdGF0dXMiLCJub3RlcyIsImdldEFwcG9pbnRtZW50c0J5QmFyYmVyIiwib3JkZXIiLCJnZXRBcHBvaW50bWVudHNCeUNsaWVudCIsImFzY2VuZGluZyIsImNhbmNlbEFwcG9pbnRtZW50IiwiYXBwb2ludG1lbnRJZCIsInVwZGF0ZSIsInN1YnNjcmliZVRvQXBwb2ludG1lbnRzIiwib25BcHBvaW50bWVudENoYW5nZSIsImNoYW5uZWwiLCJvbiIsImV2ZW50Iiwic2NoZW1hIiwidGFibGUiLCJmaWx0ZXIiLCJwYXlsb2FkIiwibmV3Iiwic3Vic2NyaWJlIiwicmVtb3ZlQ2hhbm5lbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/booking.ts\n"));

/***/ })

});